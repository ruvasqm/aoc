#!/usr/bin/env mojo
# fg : \033[38;2;<r>;<g>;<b>m
# bg : \033[48;2;<r>;<g>;<b>m
import benchmark
from sys import argv
from os import path
from memory import memset_zero
from collections import Set
from sys import simdwidthof
from utils import Span
from sys import is_defined

alias AoCResult = UnsafePointer[Scalar[DType.uint64]]
alias AoCPart = fn (Span[char], AoCResult) raises -> None
alias mu = "Î¼s"

alias n  = 11 if is_defined["TEST"]() else 141
alias w = simdwidthof[DType.uint8]()
alias nelts = round2(min(n,w))
alias step = min(n,w)
alias MAX_SIZE = n*(n-1)
alias PADDED_SIZE = round2(n + MAX_SIZE + nelts)
alias char = SIMD[DType.uint8, 1]
alias Vec = SIMD[DType.int16, 2]

fn round2(i : Int) -> Int:
  p = 0
  while 2**p < i:
    p += 1
  return 2**p

struct Region:
    var els: Set[Int]
    var edges: Int
    var parent: Int

    fn __init__(inout self):
        self.els = Set[Int]()
        self.edges = 0
        self.parent = -1

    fn __copyinit__(inout self, existing: Self):
        self.els = Set[Int]()
        self.els = self.els.union(existing.els)
        self.edges = existing.edges
        self.parent = existing.parent

    fn __moveinit__(inout self, owned existing: Self):
        self.els = existing.els^
        self.edges = existing.edges
        self.parent = existing.parent

    fn __eq__(self, b: Self) -> Bool:
        return self.parent == b.parent
    fn __contains__(self, v: Int) -> Bool:
      return v in self.els


fn p1(l: Span[char],  r: AoCResult) raises -> None:
    var edges = UnsafePointer[char].alloc(PADDED_SIZE)
    memset_zero(edges.address, PADDED_SIZE)
    var padded = UnsafePointer[char].alloc(PADDED_SIZE)
    padded.store[width=PADDED_SIZE](SIMD[DType.uint8,PADDED_SIZE](ord('\n')))
    padded.store[width=MAX_SIZE](n, l._data.load[width=MAX_SIZE]())
    regions = List[Region]()
    print(nelts)
    # debug_assert(nelts == n, "OHHFUCK")
    edges.store[width=n-1](n, 1)

    for i in range(n, MAX_SIZE+n , n):
        c = padded.load[width=nelts](i)
        f = padded.load[width=nelts](i+1)
        b = padded.load[width=nelts](i-1)
        d = padded.load[width=nelts](i+n)
        unity = SIMD[DType.uint8,nelts](1)
        f_ne = (c != f).select(unity, 0 & unity)
        b_ne = (c != b).select(unity, 0 & unity)
        d_ne = (c != d ).select(unity, 0 & unity)
        s_edge = edges.load[width=nelts](i)
        self_edges = (s_edge + f_ne + d_ne + b_ne)
        edges.store[width=n](i,self_edges.slice[n, offset=0]())
        print(self_edges)
    for i in range(n, MAX_SIZE+n,step):
      print(edges.load[width=step-1](i), padded.load[width=nelts](i))

        #print(edges.load[width=1](j * n + i), end="")

    r.store[width=1](0)


fn p2(l: Span[SIMD[DType.uint8, 1]], r: AoCResult) raises -> None:
    pass


fn main() raises:
        alias mode = "test" if is_defined["TEST"]() else "input"
        var filename = String(argv()[0]).replace("mojo", mode)
        var result = AoCResult.alloc(1)
        memset_zero(result.address, 1)
        var result2 = AoCResult.alloc(1)
        var s = List[char,1]()
        memset_zero(result2.address, 1)
        with open(filename, "rb") as f:
            var input = f.read().as_bytes()
            s = input
        if is_defined["BENCH"]():
            print("p1 took:", bench[p1](s, result))
            print("p2 took:", bench[p2](s, result2))
        else:
            p1(s, result)
            print("result p1:", result.load[width=1]())
            p2(s, result2)
            print("result p2:", result2.load[width=1]())


fn bench[f: AoCPart](s: Span[char], r: AoCResult) raises -> String:
    @parameter
    fn test_fn():
        try:
            _ = f(s, r)
        except:
            print("IAAAA ONIICHAN")
        pass

    m = benchmark.run[test_fn]().mean("ns") / 1e3
    m_p = str(m).split(".")
    m_s = m_p[0] + "." + m_p[1][0:2] + " " + mu + " "
    result = "result: " + str(int(r.load[width=1]()))
    a = m_s + result
    return a
